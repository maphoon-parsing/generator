
//  Copyright <2021> <Hans de Nivelle>
//
//  This software is released with the 3-clause BSD license, which 
//  is given below: 
// 
//  Redistribution and use in source and binary forms, with or without 
//  modification, are permitted provided that the following conditions are met:

//  Redistributions of source code must retain the above copyright notice, 
//  this list of conditions and the following disclaimer:

//  Redistributions in binary form must reproduce the above copyright notice, 
//  this list of conditions and the following disclaimer in the documentation 
//  and/or other materials provided with the distribution.
//  Neither the name of the copyright holder nor the names of its contributors 
//  may be used to endorse or promote products derived from this software 
//  without specific prior written permission.

//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
//  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
//  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
//  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
//  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
//  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED 
//  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
//  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
//  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



// Parser generated by Maphoon 2021.
// Written by Hans de Nivelle, March 2021.
// See the licence that was included with the code. 

#ifndef PARSER 
#define PARSER   1

#include <vector>
#include <iostream>
#include <unordered_set>
#include <unordered_map>

#include "symbol.h"

#line 109 "ambiguous.m"
 #include "varstore.h" 
 #include "filereader.h" 
 #include "tokenizing.h" 
#line 18 "idee.x"
 

  
struct parser
{

   struct statesymbol
   {
      size_t state;
      symboltype type;

      statesymbol( size_t state, symboltype type )
         : state( state ), type( type )
      { }

      struct hash
      {
         size_t operator( ) ( const statesymbol& ) const;
      };

      struct equal_to
      {
         bool operator( ) ( const statesymbol &, const statesymbol& ) const;
      };

      template< typename D > using map =
      std::unordered_map< statesymbol, D, hash, equal_to > ;
   };


   static std::unordered_map< symboltype,
      std::pair< size_t, std::unordered_set< symboltype >>> 
   startsymbols;
      // Maps possible start symbols to pairs of
      // initial state, and terminator sets.

   static 
   std::vector< std::pair< char, size_t >> reductioninfo; 
      // Indexed by the states.
      // char = 'T' : the state consists of a single reduction (trivial).
      // char = 'D' : the state has a default reduction, which will be
      //              carried out when lookahead has no shift.
      // char = 'N' : the state has no reductions.
      // char = 'H' : none of the above. The state is hard.

   static statesymbol::map< size_t > shifts; 
   static statesymbol::map< std::vector< size_t >> reductions;

   std::vector< size_t > statestack;
   std::vector< symbol > symbolstack;
   std::optional< symbol > lookahead;

   unsigned int lasterror = 999999;
      // Symbols that were processed since the last error. 

   bool timetosaygoodbye = false; 
      // If you assign true, the parser will assume that 
      // it is really time to say goodbye. No more symbols will 
      // be read. 

   short int debug = 0;  
      // 0 : no output
      // 1 : only the parse stack
      // 2 : chosen shifts and reductions
      // 3 : attempted reductions. 

   // Parameters, defined by %parameters:

   varstore<double> & memory;
   std::vector<std::string> & errorlog;
   filereader & read;


   parser( varstore<double> & memory,
           std::vector<std::string> & errorlog,
           filereader & read )
      : memory( memory ),
        errorlog( errorlog ),
        read( read )
   { }


   // i-th symbol on the symbolstack, looking backwards:
   // This means that 0 is undefined, 1 is .back( ), etc. 

   symbol& topsymbol( size_t i )
      { return *( symbolstack. end( ) - i ); }

   const symbol& topsymbol( size_t i ) const
      { return *( symbolstack. cend( ) - i ); }

#if true
   static void merge_infos( symbol::infotype& ,
                            symbol::infotype&& ); 
#endif

   void reduce( symboltype lefttype, 
                symbol::attrtype&& attr, size_t rightsize );

   symbol parse( symboltype start );

   void print( std::ostream& out ) const;
      // Prints the state of the parser.

   unsigned int syntaxerror( );
      // When we encounter an error, the parser calls this function.
      // The number returned is our patience when trying to recover.
      // 0 means that we do not try to recover at all. 10 means that 
      // we try to recover for 10 symbols, etc. I remember from Yacc
      // that 3 is a good value. 
      // 
      // First thing that the function should do is look at lasterror,
      // and decide if this is a new error, or a failure to recover from   
      // the previous error. 

   // Declarations of reduction functions and their conditions:
   // They have no arguments because they use the stack.

   void body2( );
   void body3( );
   void body4( );
   void body5( );
   void body6( );
   double body7( );
   double body8( );
   double body9( );
   double body10( );
   double body11( );
   double body12( );
   double body13( );
   double body14( );
   double body15( );
   double body16( );
   double body17( );
   double body18( );
   double body19( );
   double body20( );
   double body21( );
   std::vector<double> body22( );
   std::vector<double> body23( );
   short cond24( ) const;
   short cond25( ) const;


};



#endif

