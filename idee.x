
$$h$$

// Parser generated by Maphoon 2021.
// Written by Hans de Nivelle, March 2021.
// See the licence that was included with the code. 

#ifndef $$parserincludeguard$$ 
#define $$parserincludeguard$$   1

#include <vector>
#include <iostream>
#include <unordered_set>
#include <unordered_map>

#include "symbol.h"

$$parsercode_h$$ 

$$openparserspace$$  
struct parser
{

   struct statesymbol
   {
      size_t state;
      $$symbolspace$$symboltype type;

      statesymbol( size_t state, $$symbolspace$$symboltype type )
         : state( state ), type( type )
      { }

      struct hash
      {
         size_t operator( ) ( const statesymbol& ) const;
      };

      struct equal_to
      {
         bool operator( ) ( const statesymbol &, const statesymbol& ) const;
      };

      template< typename D > using map =
      std::unordered_map< statesymbol, D, hash, equal_to > ;
   };


   static std::unordered_map< $$symbolspace$$symboltype,
      std::pair< size_t, std::unordered_set< $$symbolspace$$symboltype >>> 
   startsymbols;
      // Maps possible start symbols to pairs of
      // initial state, and terminator sets.

   static 
   std::vector< std::pair< char, size_t >> reductioninfo; 
      // Indexed by the states.
      // char = 'T' : the state consists of a single reduction (trivial).
      // char = 'D' : the state has a default reduction, which will be
      //              carried out when lookahead has no shift.
      // char = 'N' : the state has no reductions.
      // char = 'H' : none of the above. The state is hard.

   static statesymbol::map< size_t > shifts; 
   static statesymbol::map< std::vector< size_t >> reductions;

   std::vector< size_t > statestack;
   std::vector< $$symbolspace$$symbol > symbolstack;
   std::optional< $$symbolspace$$symbol > lookahead;

   unsigned int lasterror = 999999;
      // Symbols that were processed since the last error. 

   bool timetosaygoodbye = false; 
      // If you assign true, the parser will assume that 
      // it is really time to say goodbye. No more symbols will 
      // be read. 

   short int debug = 0;  
      // 0 : no output
      // 1 : only the parse stack
      // 2 : chosen shifts and reductions
      // 3 : attempted reductions. 

   // Parameters, defined by %parameters:

$$parameterfields$$

$$constructor$$

   // i-th symbol on the symbolstack, looking backwards:
   // This means that 0 is undefined, 1 is .back( ), etc. 

   $$symbolspace$$symbol& topsymbol( size_t i )
      { return *( symbolstack. end( ) - i ); }

   const $$symbolspace$$symbol& topsymbol( size_t i ) const
      { return *( symbolstack. cend( ) - i ); }

#if $$symbolhasinfo$$
   static void merge_infos( $$symbolspace$$symbol::infotype& ,
                            $$symbolspace$$symbol::infotype&& ); 
#endif

   void reduce( $$symbolspace$$symboltype lefttype, 
                $$symbolspace$$symbol::attrtype&& attr, size_t rightsize );

   $$symbolspace$$symbol parse( $$symbolspace$$symboltype start );

   void print( std::ostream& out ) const;
      // Prints the state of the parser.

   unsigned int syntaxerror( );
      // When we encounter an error, the parser calls this function.
      // The number returned is our patience when trying to recover.
      // 0 means that we do not try to recover at all. 10 means that 
      // we try to recover for 10 symbols, etc. I remember from Yacc
      // that 3 is a good value. 
      // 
      // First thing that the function should do is look at lasterror,
      // and decide if this is a new error, or a failure to recover from   
      // the previous error. 

$$actiondeclarations$$

};

$$closeparserspace$$

#endif

$$nowhere$$
this goes nowhere.

$$cpp$$
// Parser generated by Maphoon 2021.
// Written by Hans de Nivelle, March 2021.
// See the licence that was included with the code.

#include "parser.h"

$$parsercode_cpp$$

size_t 
$$parserspace$$parser::statesymbol::hash::operator( ) ( const statesymbol& ss ) const
{
   return ss.state + ( ss.type << 4 ) + ( ss.type );
}

bool
$$parserspace$$parser::statesymbol::equal_to::operator( ) ( const statesymbol& ss1,
                                                            const statesymbol& ss2 ) const
{
   return ss1. state == ss2. state && ss1. type == ss2. type;
}

$$actiondefinitions$$

#line 1 "reduce"

void $$parserspace$$parser::reduce( $$symbolspace$$symboltype lefttype,
               $$symbolspace$$symbol::attrtype&& attr, size_t rightsize )
{
   if( debug >= 2 )
   {
      std::cout << "popping " << rightsize << " state/symbol from stack "; 
      std::cout << "and reducing into " << lefttype << "\n";
   }

#if $$symbolhasinfo$$
   // This works only if symbol has an info type: 

   std::optional< $$symbolspace$$symbol::infotype > info;
      // Look for the first symbol that has info:

   for( auto p = symbolstack. end( ) - rightsize; 
        p != symbolstack. end( ); ++ p ) 
   {
      // If we encounter first defined, we move into info. 
      // For later defineds, we call merge_infos( ).

      if( p -> info. has_value( )) 
      {
         if( info. has_value( ))
            merge_infos( info.value( ), std::move( p -> info.value() ));
         else
            info = std::move( p -> info );
      }
   }
#endif 

   while( rightsize )
   {
      statestack. pop_back( );
      symbolstack. pop_back( );
      -- rightsize; 
   }
  
   // It remains to do the goto: 

   statestack. push_back( shifts. at( { statestack. back( ), lefttype } ));

#if $$symbolhasinfo$$
   symbolstack. emplace_back( lefttype, info, std::move( attr ));
#else
   symbolstack. emplace_back( lefttype, std::move( attr ));
#endif 
}

#line 1 "parse"

$$symbolspace$$symbol 
$$parserspace$$parser::parse( $$symbolspace$$symboltype startsym )
{
   if( debug >= 2 ) 
   {
      std::cout << "Starting parser:\n";

      if( ! std::is_nothrow_move_constructible<$$symbolspace$$symbol> :: value )
      {
         std::cout << "class symbol is not nothrow move constructible\n";
         std::cout << "   (this causes loss of efficiency)\n"; 
      }
      else
      {
         std::cout << "class symbol is nothrow move constructible\n";
         std::cout << "   (that is good)\n";
      }
   }

   if( debug >= 1 && 
          startsymbols. find( startsym ) == startsymbols. end( ))
   {
      std::cout << "startsymbol " << startsym << " is not a start symbol\n";
   }
 
   const auto& startinfo = startsymbols. at( startsym );
   statestack. push_back( startinfo. first );
  
mainloop: 
   if( debug >= 1 ) 
      print( std::cout ); 

   if( timetosaygoodbye )
   {
      if( debug >= 2 ) 
         std::cout << "time to say goodbye\n";

      $$symbolspace$$symbol res = std::move( symbolstack. back( ));
      symbolstack. pop_back( );
      statestack. pop_back( );
      return res; 
   }
 
   size_t shift = reductioninfo. size( );  // Means undefined. 
   std::vector< size_t > redcandidates;

   // Decide if our state is a simple state:

   const auto& redinfo = reductioninfo[ statestack. back( ) ]; 

   // If the state is non-trivial, we need a lookahead:

   if( redinfo. first != 'T' && !lookahead. has_value( )) 
      lookahead = $$source$$  

   if( debug >= 3 && lookahead. has_value( ))
      std::cout << "lookahead " << lookahead. value( ) << "\n";

   switch( redinfo. first ) 
   {
   case 'N': 
   {
      auto p = shifts. find( 
               statesymbol( statestack.back( ), lookahead. value( ). type ));
      if( p != shifts. end( ))
         shift = p -> second;
      break;
   }
   case 'D':
   {
      auto p = shifts. find(
               statesymbol( statestack.back( ), lookahead. value( ). type ));
      if( p != shifts. end( ))
         shift = p -> second;
      else
         redcandidates. push_back( redinfo. second ); 
      break;
   }
   case 'H':
   {
      auto p = shifts. find(
               statesymbol( statestack. back( ), lookahead. value( ). type ));
      if( p != shifts. end( ))
         shift = p -> second; 
     
      auto q = reductions. find( 
               statesymbol( statestack. back( ), lookahead. value( ). type ));
      if( q != reductions. end( ))
         redcandidates = q -> second; 
      break;
   }
   case 'T':
      redcandidates. push_back( redinfo. second );
      break;   
   default:
      std::cout << redinfo.first << "\n";
      throw std::logic_error( "reduction info not recognized" );
   }
  
   if( debug >= 3 )
   { 
      if( shift != reductioninfo. size( ))
         std::cout << "shift candidate " << shift << "\n";

      if( redcandidates. size( )) 
      {
         std::cout << "reduction candidates: "; 
         for( size_t i = 0; i != redcandidates. size( ); ++ i )
            std::cout << redcandidates[i] << " ";
         std::cout << "\n";
      }
      else
         std::cout << "there are no reduction candidates\n";
   }

   // We need to find a reduction that agrees to be reduced: 

   for( const auto& r : redcandidates ) 
   {
      if( debug >= 3 ) 
         std::cout << "trying to reduce rule " << r << "\n";

      switch(r)
      {
$$reductioncases$$ 
      default:
         throw std::logic_error( "reducing unknown rule" );  
      }
   }

   if( shift < reductioninfo. size( ))
   {
      if( debug >= 2 ) 
         std::cout << "shifting S" << shift << "\n";

      statestack. push_back( shift );
      symbolstack. push_back( std::move( lookahead. value( ) ));
      lookahead. reset( );

      if( lasterror < 10000 )
         ++ lasterror; 

      goto mainloop;
   }

   if( symbolstack. size( ) == 1 && symbolstack. front( ). type == startsym )
   {
      if( debug >= 2 ) 
         std::cout << "we accept the input\n";

      $$symbolspace$$symbol res = std::move( symbolstack. front( ));
      symbolstack. clear( );
      statestack. pop_back( );
      return res;
   }

#line 1 "startpoint"

   unsigned int patience = syntaxerror( ); 
   if( patience ) 
   {
      if( debug >= 2 )
         std::cout << "trying to recover\n";

      if( debug >= 2 )
         std::cout << "patience remaining = " << patience << "\n";

      std::vector< std::pair< size_t, size_t >> shiftrecover; 
         // We collect the levels whose state can shift the  _recover_ 
         // symbol, 
         // combined with the states that will be reached after the shifts.

      for( size_t level = 0; level != statestack. size( ); ++ level )
      {
         size_t s = statestack[ level ];

         if( reductioninfo[s]. first == 'N' ||
             reductioninfo[s]. first == 'D' ||
             reductioninfo[s]. first == 'H' )
         {
            auto p = shifts. find( statesymbol( s, $$symbolspace$$sym__recover_ ));
            if( p != shifts. end( ))
               shiftrecover. push_back( std::pair( level, p -> second ));
         }
      } 

      std::cout << "{";
      for( auto p = shiftrecover. begin( ); p != shiftrecover. end( ); ++ p )
      {
         if( p != shiftrecover. begin( ))
            std::cout << ", ";
         else
            std::cout << " ";
         std::cout << ( p -> first ) << "/" << ( p -> second );
      }
      std::cout << " }\n";

      if( shiftrecover. size( ) == 0 )
      {
         std::cout << "no recovering shifts found\n";
         std::cout << lookahead. value( ) << "\n";
         return lookahead. value( );
      }

      std::cout << "lookahead = " << lookahead. value( ) << "\n";

      // While we still have patience, and the lookahead is not
      // in the terminator set, we try to recover: 
 
      while( patience && 
             startinfo. second. count( lookahead. value( ). type ) == 0 )
      {
         // We look in shiftrecover for the highest level on
         // which we could shift current lookahead after shifting the 
         // _recover_ symbol. 

         size_t rec = shiftrecover. size( ); 
         while( rec != 0 ) 
         { 
            -- rec; 
            size_t s = shiftrecover[ rec ]. second; 
            
            if( reductioninfo[s]. first == 'N' ||
                reductioninfo[s]. first == 'D' ||
                reductioninfo[s]. first == 'H' )
            {
               auto after = shifts. find( 
                      statesymbol( s, lookahead. value( ). type ));

               if( after != shifts. end( ))
               {
                  std::cout << rec << " is candidate\n";
                  std::cout << "recovery will be into state ";
                  std::cout << after -> second << "\n";

                  while( statestack. size() > shiftrecover[ rec ]. first + 1 )
                  {
                     statestack. pop_back( );
                     symbolstack. pop_back( );  
                  } 
                  
                  statestack. push_back(s);
#if $$symbolhasinfo$$
                  symbolstack. push_back( 
                     $$symbolspace$$symbol( $$symbolspace$$sym__recover_, 
                             std::optional< $$symbolspace$$symbol::infotype > ( ))); 
#else
                  symbolstack. push_back( 
                     $$symbolspace$$symbol( $$symbolspace$$sym__recover_ ));
#endif 
                  statestack. push_back( after -> second );
                  symbolstack. push_back( std::move( lookahead. value( ) ));
                  lookahead. reset( );

                  lasterror = 0;

                  print( std::cout );  
                  std::cout <<  "we are recovered!" << "\n\n";
                  goto mainloop; 
               } 
            }
         }

         // We throw away the current lookahead,
         // and lose a bit of our patience. 

         std::cout << "not yet recovered, patience = " << patience << "\n";
         lookahead = $$source$$
         -- patience; 
      }
   }

   // That's it. Game over. We lost.

   if( debug )
   {
      if( !patience ) 
         std::cout << "recovery ran out of patience\n";
      else
         std::cout << "reached a terminator\n";
   }

#if $$symbolhasinfo$$
   return $$symbolspace$$symbol( $$symbolspace$$sym__recover_,
                  std::optional< $$symbolspace$$symbol::infotype > ( ) );
#else
   return $$symbolspace$$symbol( $$symbolspace$$sym__recover_ );
#endif

}

#if ! $$usererror$$ 

unsigned int 
$$parserspace$$parser::syntaxerror( )
{
   if( lasterror > 3 ) 
   {
      std::cout << "this looks like a new syntax error\n"; 
      return 6;
   }
   else
   {
      std::cout << "this looks like a failed recovery\n";
      return 6 - lasterror;
         // Possible because lasterror <= 3.
   }   
}

#endif

void 
$$parserspace$$parser::print( std::ostream& out ) const
{
   out << "Statestack: ";
   for( auto s : statestack )
      out << "S" << s << " ";
   out << "\n";

   out << "Symbolstack: ";
   for( const auto& s : symbolstack )
      out << s << "  ";
   out << "\n";
   if( lasterror < 10000 )
      out << "last error was " << lasterror << " symbols ago\n";

}

$$maintables$$

$$end$$

