
//  Copyright <2021> <Hans de Nivelle>
//
//  This software is released with the 3-clause BSD license, which 
//  is given below: 
// 
//  Redistribution and use in source and binary forms, with or without 
//  modification, are permitted provided that the following conditions are met:

//  Redistributions of source code must retain the above copyright notice, 
//  this list of conditions and the following disclaimer:

//  Redistributions in binary form must reproduce the above copyright notice, 
//  this list of conditions and the following disclaimer in the documentation 
//  and/or other materials provided with the distribution.
//  Neither the name of the copyright holder nor the names of its contributors 
//  may be used to endorse or promote products derived from this software 
//  without specific prior written permission.

//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
//  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
//  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
//  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
//  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
//  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED 
//  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
//  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
//  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


// Parser generated by Maphoon 2021.
// Written by Hans de Nivelle, March 2021.
// See the licence that was included with the code.

#include "parser.h"

#line 41 "grammar.m"

   namespace
   {

      // We are deciding about reducing t1.
      // 1 : we reduce
      // 0 : we don't reduce
      // -1 : we do not even shift.

      short int decide( symboltype t1, symboltype t2 ) 
      {
         // std::cout << "Deciding between: " << t1 << " " << t2 << "\n";

         if( t1 == sym_NOT || t1 == sym_DIA || t1 == sym_BOX || t1 == sym_AND )
            return 1;

         if( t1 == sym_OR )
         {
            if( t2 == sym_AND ) 
               return 0;
            return 1;
         }

         if( t1 == sym_IMP )
         {
            if( t2 == sym_AND || t2 == sym_OR || t2 == sym_IMP )
               return 0;
            return 1;
         }

         if( t1 == sym_EQUIV )
         {
            if( t2 == sym_AND || t2 == sym_OR || t2 == sym_IMP )
               return 0; 
            if( t2 == sym_EQUIV )
               return -1;
            return 1; 
         }

         throw std::runtime_error( "should be unreachable" ); 
      }
   }

#line 141 "idee.x"


size_t 
parser::statesymbol::hash::operator( ) ( const statesymbol& ss ) const
{
   return ss.state + ( ss.type << 4 ) + ( ss.type );
}

bool
parser::statesymbol::equal_to::operator( ) ( const statesymbol& ss1,
                                                            const statesymbol& ss2 ) const
{
   return ss1. state == ss2. state && ss1. type == ss2. type;
}


// Definitions of the reduction functions:

form parser::body2( )
{
#line 100 "grammar.m"
 std::cout << "    formula: "; (topsymbol(2).get<form>()). printprefix( std::cout ); 
     std::cout << "\n"; return (topsymbol(2).get<form>()); }

form parser::body3( )
{
#line 104 "grammar.m"
 std::cout << "returning ";
     (topsymbol(2).get<form>()). printprefix( std::cout ); 
     timetosaygoodbye = true; return (topsymbol(2).get<form>()); }

form parser::body4( )
{
#line 109 "grammar.m"
 vs. assign( (topsymbol(4).get<std::string>()), (topsymbol(2).get<form>()) ); return (topsymbol(2).get<form>()); }

form parser::body5( )
{
#line 112 "grammar.m"
 return form( "ERROR" ); }

form parser::body6( )
{
#line 115 "grammar.m"
 return form( "ERROR" ); }

form parser::body7( )
{
#line 118 "grammar.m"
 return form( "ERROR" ); }

form parser::body8( )
{
#line 122 "grammar.m"
 return (topsymbol(1).get<std::string>()); }

form parser::body9( )
{
#line 124 "grammar.m"
 return form( (topsymbol(1).get<bool>()) ? op_true : op_false ); }

short parser::cond10( ) const
{
#line 129 "grammar.m"
 return decide( sym_NOT, lookahead. value( ). type ); }

form parser::body10( )
{
#line 131 "grammar.m"
 return form( op_not, (topsymbol(1).get<form>()) ); }

short parser::cond11( ) const
{
#line 136 "grammar.m"
 return decide( sym_AND, lookahead. value( ). type ); }

form parser::body11( )
{
#line 138 "grammar.m"
 return form( op_and, (topsymbol(3).get<form>()), (topsymbol(1).get<form>()) ); }

short parser::cond12( ) const
{
#line 143 "grammar.m"
 return decide( sym_OR, lookahead. value( ). type ); }

form parser::body12( )
{
#line 145 "grammar.m"
 return form( op_or, (topsymbol(3).get<form>()), (topsymbol(1).get<form>()) ); }

short parser::cond13( ) const
{
#line 150 "grammar.m"
 return decide( sym_IMP, lookahead. value( ). type ); }

form parser::body13( )
{
#line 152 "grammar.m"
 return form( op_imp, (topsymbol(3).get<form>()), (topsymbol(1).get<form>()) ); }

short parser::cond14( ) const
{
#line 157 "grammar.m"
 return decide( sym_EQUIV, lookahead. value( ). type ); }

form parser::body14( )
{
#line 159 "grammar.m"
 return form( op_equiv, (topsymbol(3).get<form>()), (topsymbol(1).get<form>()) ); }

short parser::cond15( ) const
{
#line 164 "grammar.m"
 return decide( sym_BOX, lookahead. value( ). type ); }

form parser::body15( )
{
#line 166 "grammar.m"
 return form( op_box, (topsymbol(2).get<agent>()), (topsymbol(1).get<form>()) ); }

short parser::cond16( ) const
{
#line 171 "grammar.m"
 return decide( sym_BOX, lookahead. value( ). type ); }

form parser::body16( )
{
#line 173 "grammar.m"
 return form( op_box, (topsymbol(3).get<agent>()), (topsymbol(1).get<form>()) ); }

short parser::cond17( ) const
{
#line 178 "grammar.m"
 return decide( sym_DIA, lookahead. value( ). type ); }

form parser::body17( )
{
#line 180 "grammar.m"
 return form( op_dia, (topsymbol(2).get<agent>()), (topsymbol(1).get<form>()) ); }

short parser::cond18( ) const
{
#line 185 "grammar.m"
 return decide( sym_DIA, lookahead. value( ). type ); }

form parser::body18( )
{
#line 187 "grammar.m"
 return form( op_dia, (topsymbol(3).get<agent>()), (topsymbol(1).get<form>()) ); }

short parser::cond19( ) const
{
#line 192 "grammar.m"
 return decide( sym_DIA, lookahead. value( ). type ); }

form parser::body19( )
{
#line 194 "grammar.m"
 return form( op_box, "#1", (topsymbol(1).get<form>()) ); }

short parser::cond20( ) const
{
#line 199 "grammar.m"
 return decide( sym_BOX, lookahead. value( ). type ); }

form parser::body20( )
{
#line 201 "grammar.m"
 return form( op_dia, "#1", (topsymbol(1).get<form>()) ); }

form parser::body21( )
{
#line 203 "grammar.m"
 return (topsymbol(2).get<form>()); }

form parser::body22( )
{
#line 206 "grammar.m"
 return form( op_dia, agent( "ERROR" ), op_false ); }

form parser::body23( )
{
#line 210 "grammar.m"

      if( vs. contains( (topsymbol(1).get<std::string>()) ))
         return *vs. lookup( (topsymbol(1).get<std::string>()) ); 
      else
         return form( op_dia, agent( "NOT FOUND" ), op_false ); 
   }

form parser::body24( )
{
#line 218 "grammar.m"
 return (topsymbol(2).get<form>()). nnf(1); }

form parser::body25( )
{
#line 221 "grammar.m"
 return form( op_dia, agent( "wrong NNF" ), op_false ); }

std::string parser::body26( )
{
#line 225 "grammar.m"
 return (topsymbol(1).get<std::string>()); }

agent parser::body27( )
{
#line 227 "grammar.m"
 return (topsymbol(1).get<std::string>()); }

agent parser::body28( )
{
#line 228 "grammar.m"
 return std::string( "#" ) + std::to_string((topsymbol(1).get<unsigned int>())); }



#line 1 "reduce"

void parser::reduce( symboltype lefttype,
               symbol::attrtype&& attr, size_t rightsize )
{
   if( debug >= 2 )
   {
      std::cout << "popping " << rightsize << " state/symbol from stack "; 
      std::cout << "and reducing into " << lefttype << "\n";
   }

#if false
   // This works only if symbol has an info type: 

   std::optional< symbol::infotype > info;
      // Look for the first symbol that has info:

   for( auto p = symbolstack. end( ) - rightsize; 
        p != symbolstack. end( ); ++ p ) 
   {
      // If we encounter first defined, we move into info. 
      // For later defineds, we call merge_infos( ).

      if( p -> info. has_value( )) 
      {
         if( info. has_value( ))
            merge_infos( info.value( ), std::move( p -> info.value() ));
         else
            info = std::move( p -> info );
      }
   }
#endif 

   while( rightsize )
   {
      statestack. pop_back( );
      symbolstack. pop_back( );
      -- rightsize; 
   }
  
   // It remains to do the goto: 

   statestack. push_back( shifts. at( { statestack. back( ), lefttype } ));

#if false
   symbolstack. emplace_back( lefttype, info, std::move( attr ));
#else
   symbolstack. emplace_back( lefttype, std::move( attr ));
#endif 
}

#line 1 "parse"

symbol 
parser::parse( symboltype startsym )
{
   if( debug >= 2 ) 
   {
      std::cout << "Starting parser:\n";

      if( ! std::is_nothrow_move_constructible<symbol> :: value )
      {
         std::cout << "class symbol is not nothrow move constructible\n";
         std::cout << "   (this causes loss of efficiency)\n"; 
      }
      else
      {
         std::cout << "class symbol is nothrow move constructible\n";
         std::cout << "   (that is good)\n";
      }
   }

   if( debug >= 1 && 
          startsymbols. find( startsym ) == startsymbols. end( ))
   {
      std::cout << "startsymbol " << startsym << " is not a start symbol\n";
   }
 
   const auto& startinfo = startsymbols. at( startsym );
   statestack. push_back( startinfo. first );
  
mainloop: 
   if( debug >= 1 ) 
      print( std::cout ); 

   if( timetosaygoodbye )
   {
      if( debug >= 2 ) 
         std::cout << "time to say goodbye\n";

      symbol res = std::move( symbolstack. back( ));
      symbolstack. pop_back( );
      statestack. pop_back( );
      return res; 
   }
 
   size_t shift = reductioninfo. size( );  // Means undefined. 
   std::vector< size_t > redcandidates;

   // Decide if our state is a simple state:

   const auto& redinfo = reductioninfo[ statestack. back( ) ]; 

   // If the state is non-trivial, we need a lookahead:

   if( redinfo. first != 'T' && !lookahead. has_value( )) 
      lookahead =  tok. get( ); 
  

   if( debug >= 3 && lookahead. has_value( ))
      std::cout << "lookahead " << lookahead. value( ) << "\n";

   switch( redinfo. first ) 
   {
   case 'N': 
   {
      auto p = shifts. find( 
               statesymbol( statestack.back( ), lookahead. value( ). type ));
      if( p != shifts. end( ))
         shift = p -> second;
      break;
   }
   case 'D':
   {
      auto p = shifts. find(
               statesymbol( statestack.back( ), lookahead. value( ). type ));
      if( p != shifts. end( ))
         shift = p -> second;
      else
         redcandidates. push_back( redinfo. second ); 
      break;
   }
   case 'H':
   {
      auto p = shifts. find(
               statesymbol( statestack. back( ), lookahead. value( ). type ));
      if( p != shifts. end( ))
         shift = p -> second; 
     
      auto q = reductions. find( 
               statesymbol( statestack. back( ), lookahead. value( ). type ));
      if( q != reductions. end( ))
         redcandidates = q -> second; 
      break;
   }
   case 'T':
      redcandidates. push_back( redinfo. second );
      break;   
   default:
      std::cout << redinfo.first << "\n";
      throw std::logic_error( "reduction info not recognized" );
   }
  
   if( debug >= 3 )
   { 
      if( shift != reductioninfo. size( ))
         std::cout << "shift candidate " << shift << "\n";

      if( redcandidates. size( )) 
      {
         std::cout << "reduction candidates: "; 
         for( size_t i = 0; i != redcandidates. size( ); ++ i )
            std::cout << redcandidates[i] << " ";
         std::cout << "\n";
      }
      else
         std::cout << "there are no reduction candidates\n";
   }

   // We need to find a reduction that agrees to be reduced: 

   for( const auto& r : redcandidates ) 
   {
      if( debug >= 3 ) 
         std::cout << "trying to reduce rule " << r << "\n";

      switch(r)
      {
      case 0:
         reduce( sym_Session, std::monostate( ), 2 );
         goto mainloop;
         break;
      case 1:
         reduce( sym_Session, std::monostate( ), 0 );
         goto mainloop;
         break;
      case 2:
         reduce( sym_Command, body2( ), 2 );
         goto mainloop;
         break;
      case 3:
         reduce( sym_Command, body3( ), 3 );
         goto mainloop;
         break;
      case 4:
         reduce( sym_Command, body4( ), 4 );
         goto mainloop;
         break;
      case 5:
         reduce( sym_Command, body5( ), 2 );
         goto mainloop;
         break;
      case 6:
         reduce( sym_Command, body6( ), 3 );
         goto mainloop;
         break;
      case 7:
         reduce( sym_Command, body7( ), 3 );
         goto mainloop;
         break;
      case 8:
         reduce( sym_Formula, body8( ), 1 );
         goto mainloop;
         break;
      case 9:
         reduce( sym_Formula, body9( ), 1 );
         goto mainloop;
         break;
      case 10:
         if( short s = cond10(); s > 0 )
         {
            reduce( sym_Formula, body10( ), 2 );
            goto mainloop;
         }
         else
            if( s < 0 ) shift = reductioninfo. size( );
         break;
      case 11:
         if( short s = cond11(); s > 0 )
         {
            reduce( sym_Formula, body11( ), 3 );
            goto mainloop;
         }
         else
            if( s < 0 ) shift = reductioninfo. size( );
         break;
      case 12:
         if( short s = cond12(); s > 0 )
         {
            reduce( sym_Formula, body12( ), 3 );
            goto mainloop;
         }
         else
            if( s < 0 ) shift = reductioninfo. size( );
         break;
      case 13:
         if( short s = cond13(); s > 0 )
         {
            reduce( sym_Formula, body13( ), 3 );
            goto mainloop;
         }
         else
            if( s < 0 ) shift = reductioninfo. size( );
         break;
      case 14:
         if( short s = cond14(); s > 0 )
         {
            reduce( sym_Formula, body14( ), 3 );
            goto mainloop;
         }
         else
            if( s < 0 ) shift = reductioninfo. size( );
         break;
      case 15:
         if( short s = cond15(); s > 0 )
         {
            reduce( sym_Formula, body15( ), 3 );
            goto mainloop;
         }
         else
            if( s < 0 ) shift = reductioninfo. size( );
         break;
      case 16:
         if( short s = cond16(); s > 0 )
         {
            reduce( sym_Formula, body16( ), 4 );
            goto mainloop;
         }
         else
            if( s < 0 ) shift = reductioninfo. size( );
         break;
      case 17:
         if( short s = cond17(); s > 0 )
         {
            reduce( sym_Formula, body17( ), 3 );
            goto mainloop;
         }
         else
            if( s < 0 ) shift = reductioninfo. size( );
         break;
      case 18:
         if( short s = cond18(); s > 0 )
         {
            reduce( sym_Formula, body18( ), 4 );
            goto mainloop;
         }
         else
            if( s < 0 ) shift = reductioninfo. size( );
         break;
      case 19:
         if( short s = cond19(); s > 0 )
         {
            reduce( sym_Formula, body19( ), 2 );
            goto mainloop;
         }
         else
            if( s < 0 ) shift = reductioninfo. size( );
         break;
      case 20:
         if( short s = cond20(); s > 0 )
         {
            reduce( sym_Formula, body20( ), 2 );
            goto mainloop;
         }
         else
            if( s < 0 ) shift = reductioninfo. size( );
         break;
      case 21:
         reduce( sym_Formula, body21( ), 3 );
         goto mainloop;
         break;
      case 22:
         reduce( sym_Formula, body22( ), 3 );
         goto mainloop;
         break;
      case 23:
         reduce( sym_Formula, body23( ), 1 );
         goto mainloop;
         break;
      case 24:
         reduce( sym_Formula, body24( ), 4 );
         goto mainloop;
         break;
      case 25:
         reduce( sym_Formula, body25( ), 4 );
         goto mainloop;
         break;
      case 26:
         reduce( sym_Var, body26( ), 1 );
         goto mainloop;
         break;
      case 27:
         reduce( sym_Index, body27( ), 1 );
         goto mainloop;
         break;
      case 28:
         reduce( sym_Index, body28( ), 1 );
         goto mainloop;
         break;
 
      default:
         throw std::logic_error( "reducing unknown rule" );  
      }
   }

   if( shift < reductioninfo. size( ))
   {
      if( debug >= 2 ) 
         std::cout << "shifting S" << shift << "\n";

      statestack. push_back( shift );
      symbolstack. push_back( std::move( lookahead. value( ) ));
      lookahead. reset( );

      if( lasterror < 10000 )
         ++ lasterror; 

      goto mainloop;
   }

   // We accept if the stack consists of exactly the start symbol, 
   // and we have no lookahead or the lookahead is a terminator.

   if( symbolstack. size( ) == 1 &&
       symbolstack. front( ). type == startsym &&
          ( !lookahead. has_value( ) ||
            startinfo. second. count( lookahead. value( ). type )))
   {
      if( debug >= 2 ) 
         std::cout << "we accept the input\n";

      symbol res = std::move( symbolstack. front( ));
      symbolstack. clear( );
      statestack. pop_back( );
      return res;
   }

#line 1 "startpoint"

   unsigned int patience = syntaxerror( ); 
   if( patience ) 
   {
      if( debug >= 2 )
         std::cout << "trying to recover\n";

      if( debug >= 2 )
         std::cout << "patience remaining = " << patience << "\n";

      std::vector< std::pair< size_t, size_t >> shiftrecover; 
         // We collect the levels whose state can shift the  _recover_ 
         // symbol, 
         // combined with the states that will be reached after the shifts.

      for( size_t level = 0; level != statestack. size( ); ++ level )
      {
         size_t s = statestack[ level ];

         if( reductioninfo[s]. first == 'N' ||
             reductioninfo[s]. first == 'D' ||
             reductioninfo[s]. first == 'H' )
         {
            auto p = shifts. find( statesymbol( s, sym__recover_ ));
            if( p != shifts. end( ))
               shiftrecover. push_back( std::pair( level, p -> second ));
         }
      } 

 
      if( debug >= 1 )
      { 
         std::cout << "reachable after _recover_ : {";
         for( auto p = shiftrecover. begin( ); p != shiftrecover. end( ); ++ p )
         {
            if( p != shiftrecover. begin( ))
               std::cout << ", ";
            else
               std::cout << " ";
            std::cout << ( p -> first ) << "/S" << ( p -> second );
         }
         std::cout << " }\n";
      }

      if( shiftrecover. size( ) == 0 )
      {
         if( debug >= 1 )
         {
            std::cout << "no recovering shifts found\n";
            std::cout << lookahead. value( ) << "\n";
         }
         return lookahead. value( );
      }

      if( debug >= 2 ) 
         std::cout << "lookahead = " << lookahead. value( ) << "\n";

      // While we still have patience, and the lookahead is not
      // in the terminator set, we try to recover: 
 
      while( patience && 
             startinfo. second. count( lookahead. value( ). type ) == 0 )
      {
         // We look in shiftrecover for the highest level on
         // which we could shift current lookahead after shifting the 
         // _recover_ symbol. 

         size_t rec = shiftrecover. size( ); 
         while( rec != 0 ) 
         { 
            -- rec; 
            size_t s = shiftrecover[ rec ]. second; 
            
            if( reductioninfo[s]. first == 'N' ||
                reductioninfo[s]. first == 'D' ||
                reductioninfo[s]. first == 'H' )
            {
               auto after = shifts. find( 
                      statesymbol( s, lookahead. value( ). type ));

               if( after != shifts. end( ))
               {
                  if( debug >= 2 )
                  {
                     std::cout << rec << " is candidate\n";
                     std::cout << "recovery will be into state ";
                     std::cout << after -> second << "\n";
                  }

                  while( statestack. size() > shiftrecover[ rec ]. first + 1 )
                  {
                     statestack. pop_back( );
                     symbolstack. pop_back( );  
                  } 
                  
                  statestack. push_back(s);
#if false
                  symbolstack. push_back( 
                     symbol( sym__recover_, 
                             std::optional< symbol::infotype > ( ))); 
#else
                  symbolstack. push_back( 
                     symbol( sym__recover_ ));
#endif 
                  statestack. push_back( after -> second );
                  symbolstack. push_back( std::move( lookahead. value( ) ));
                  lookahead. reset( );

                  lasterror = 0;

                  if( debug >= 2 ) 
                  {
                     std::cout <<  "recovery complete" << "\n";
                  }
                  goto mainloop; 
               } 
            }
         }

         // We throw away the current lookahead,
         // and lose a bit of our patience. 
 
         if( debug >= 1 ) 
         {
            std::cout << "not yet recovered, patience = " << patience << "\n";
         }
         lookahead =  tok. get( ); 

         -- patience; 
      }
   }

   // That's it. Game over. We lost.

   if( debug )
   {
      if( !patience ) 
         std::cout << "recovery ran out of patience\n";
      else
         std::cout << "reached a terminator\n";
   }

#if false
   return symbol( sym__recover_,
                  std::optional< symbol::infotype > ( ) );
#else
   return symbol( sym__recover_ );
#endif

}

#if ! false 

unsigned int 
parser::syntaxerror( )
{
   if( lasterror > 3 ) 
   {
      std::cout << "this looks like a new syntax error\n"; 
      return 6;
   }
   else
   {
      std::cout << "this looks like a failed recovery\n";
      return 6 - lasterror;
         // Possible because lasterror <= 3.
   }   
}

#endif

void 
parser::print( std::ostream& out ) const
{
   out << "Statestack: ";
   for( auto s : statestack )
      out << "S" << s << " ";
   out << "\n";

   out << "Symbolstack: ";
   for( const auto& s : symbolstack )
      out << s << "  ";
   out << "\n";
   if( lasterror < 10000 )
      out << "last error was " << lasterror << " symbols ago\n";

}

std::unordered_map< symboltype, std::pair< size_t, std::unordered_set< symboltype >>> parser::startsymbols =
{
   { sym_Session, { 0, { sym_EOF }} }
};

std::vector< std::pair< char, size_t >> parser::reductioninfo =
{
   { 'D', 1 }, { 'N', 0 }, { 'T', 0 }, { 'T', 9 }, { 'N', 0 }, { 'N', 0 }, { 'T', 8 }, { 'N', 0 },
   { 'N', 0 }, { 'N', 0 }, { 'D', 23 }, { 'N', 0 }, { 'N', 0 }, { 'T', 26 }, { 'N', 0 }, { 'N', 0 },
   { 'N', 0 }, { 'N', 0 }, { 'N', 0 }, { 'T', 23 }, { 'H', 0 }, { 'T', 27 }, { 'T', 28 }, { 'N', 0 },
   { 'N', 0 }, { 'N', 0 }, { 'N', 0 }, { 'T', 5 }, { 'N', 0 }, { 'N', 0 }, { 'T', 2 }, { 'N', 0 },
   { 'N', 0 }, { 'N', 0 }, { 'N', 0 }, { 'N', 0 }, { 'N', 0 }, { 'N', 0 }, { 'H', 0 }, { 'H', 0 },
   { 'N', 0 }, { 'H', 0 }, { 'N', 0 }, { 'N', 0 }, { 'N', 0 }, { 'T', 22 }, { 'T', 21 }, { 'N', 0 },
   { 'N', 0 }, { 'N', 0 }, { 'H', 0 }, { 'H', 0 }, { 'H', 0 }, { 'H', 0 }, { 'T', 3 }, { 'T', 6 },
   { 'T', 7 }, { 'H', 0 }, { 'H', 0 }, { 'H', 0 }, { 'H', 0 }, { 'T', 4 }, { 'T', 25 }, { 'T', 24 }
};

parser::statesymbol::map< size_t > parser::shifts =
{
   { { 60, sym_IMP }, 32 }, { { 60, sym_AND }, 33 }, { { 60, sym_OR }, 31 }, { { 59, sym_AND }, 33 }, { { 59, sym_OR }, 31 },
   { { 53, sym_OR }, 31 }, { { 53, sym_AND }, 33 }, { { 53, sym_EQUIV }, 34 }, { { 52, sym_IMP }, 32 }, { { 52, sym_EQUIV }, 34 },
   { { 52, sym_AND }, 33 }, { { 51, sym_EQUIV }, 34 }, { { 51, sym_AND }, 33 }, { { 50, sym_EQUIV }, 34 }, { { 50, sym_AND }, 33 },
   { { 50, sym_OR }, 31 }, { { 49, sym_IMP }, 32 }, { { 29, sym_Var }, 6 }, { { 29, sym_ID }, 13 }, { { 43, sym_NNF }, 11 },
   { { 28, sym_NOT }, 4 }, { { 28, sym_BOX }, 18 }, { { 51, sym_OR }, 31 }, { { 11, sym_LEFTPAR }, 29 }, { { 28, sym_DIA }, 17 },
   { { 28, sym_CONST }, 3 }, { { 43, sym_DIASTART }, 7 }, { { 28, sym_DIASTART }, 7 }, { { 52, sym_OR }, 31 }, { { 14, sym_ID }, 13 },
   { { 28, sym_ID }, 13 }, { { 42, sym_NNF }, 11 }, { { 18, sym_NUMBER }, 22 }, { { 43, sym_DIA }, 17 }, { { 26, sym_EQUIV }, 34 },
   { { 25, sym_RIGHTPAR }, 45 }, { { 42, sym_DIA }, 17 }, { { 43, sym_Var }, 6 }, { { 26, sym_OR }, 31 }, { { 58, sym_IMP }, 32 },
   { { 18, sym_BOX }, 18 }, { { 18, sym_METAVAR }, 19 }, { { 20, sym_AND }, 33 }, { { 18, sym_NOT }, 4 }, { { 23, sym_BOXEND }, 43 },
   { { 18, sym_Index }, 42 }, { { 18, sym_CONST }, 3 }, { { 60, sym_EQUIV }, 34 }, { { 33, sym_DIASTART }, 7 }, { { 58, sym_OR }, 31 },
   { { 18, sym_LEFTPAR }, 8 }, { { 1, sym_BOXSTART }, 5 }, { { 20, sym_IMP }, 32 }, { { 18, sym_NNF }, 11 }, { { 4, sym_ID }, 13 },
   { { 18, sym_DIASTART }, 7 }, { { 18, sym_Var }, 6 }, { { 18, sym_ID }, 39 }, { { 51, sym_IMP }, 32 }, { { 29, sym_Formula }, 49 },
   { { 32, sym_NNF }, 11 }, { { 20, sym_EQUIV }, 34 }, { { 18, sym_Formula }, 41 }, { { 7, sym_ID }, 21 }, { { 18, sym_BOXSTART }, 5 },
   { { 1, sym_DIASTART }, 7 }, { { 58, sym_AND }, 33 }, { { 18, sym_DIA }, 17 }, { { 1, sym_RIGHTPAR }, 15 }, { { 57, sym_IMP }, 32 },
   { { 17, sym_BOX }, 18 }, { { 34, sym_Formula }, 53 }, { { 17, sym_NUMBER }, 22 }, { { 20, sym_OR }, 31 }, { { 59, sym_EQUIV }, 34 },
   { { 32, sym_DIASTART }, 7 }, { { 57, sym_OR }, 31 }, { { 17, sym_LEFTPAR }, 8 }, { { 34, sym_BOX }, 18 }, { { 17, sym_Var }, 6 },
   { { 28, sym_METAVAR }, 19 }, { { 17, sym_Formula }, 38 }, { { 57, sym_AND }, 33 }, { { 17, sym_DIA }, 17 }, { { 14, sym_METAVAR }, 19 },
   { { 33, sym_NOT }, 4 }, { { 14, sym_BOXSTART }, 5 }, { { 14, sym_DIA }, 17 }, { { 17, sym_BOXSTART }, 5 }, { { 34, sym_LEFTPAR }, 8 },
   { { 32, sym_Formula }, 51 }, { { 14, sym_BOX }, 18 }, { { 14, sym_CONST }, 3 }, { { 29, sym_DIASTART }, 7 }, { { 17, sym_DIASTART }, 7 },
   { { 34, sym_BOXSTART }, 5 }, { { 14, sym_LEFTPAR }, 8 }, { { 31, sym_BOX }, 18 }, { { 1, sym_Command }, 2 }, { { 35, sym_EQUIV }, 34 },
   { { 8, sym_DIASTART }, 7 }, { { 16, sym__recover_ }, 37 }, { { 4, sym_DIA }, 17 }, { { 1, sym_LEFTPAR }, 8 }, { { 41, sym_OR }, 31 },
   { { 26, sym_IMP }, 32 }, { { 4, sym_Formula }, 20 }, { { 50, sym_IMP }, 32 }, { { 28, sym_Formula }, 47 }, { { 17, sym_ID }, 39 },
   { { 40, sym_CONST }, 3 }, { { 31, sym_NNF }, 11 }, { { 4, sym_CONST }, 3 }, { { 4, sym_LEFTPAR }, 8 }, { { 40, sym_Formula }, 57 },
   { { 4, sym_Var }, 6 }, { { 8, sym__recover_ }, 25 }, { { 1, sym_NOT }, 4 }, { { 12, sym_IMP }, 32 }, { { 29, sym_CONST }, 3 },
   { { 1, sym_Formula }, 12 }, { { 4, sym_NNF }, 11 }, { { 38, sym_OR }, 31 }, { { 28, sym_BOXSTART }, 5 }, { { 1, sym_METAVAR }, 10 },
   { { 26, sym_AND }, 33 }, { { 44, sym_DIASTART }, 7 }, { { 7, sym_NUMBER }, 22 }, { { 32, sym_CONST }, 3 }, { { 1, sym__recover_ }, 9 },
   { { 8, sym_BOXSTART }, 5 }, { { 42, sym_BOX }, 18 }, { { 31, sym_LEFTPAR }, 8 }, { { 33, sym_ID }, 13 }, { { 1, sym_CONST }, 3 },
   { { 33, sym_BOXSTART }, 5 }, { { 1, sym_BOXEND }, 16 }, { { 17, sym_NOT }, 4 }, { { 8, sym_METAVAR }, 19 }, { { 0, sym_Session }, 1 },
   { { 8, sym_Formula }, 26 }, { { 8, sym_DIA }, 17 }, { { 28, sym_LEFTPAR }, 8 }, { { 1, sym_RETURN }, 14 }, { { 9, sym_SEMICOLON }, 27 },
   { { 38, sym_AND }, 33 }, { { 35, sym_SEMICOLON }, 54 }, { { 4, sym_BOXSTART }, 5 }, { { 44, sym_Formula }, 60 }, { { 8, sym_Var }, 6 },
   { { 40, sym_DIA }, 17 }, { { 28, sym_Var }, 6 }, { { 17, sym_Index }, 40 }, { { 1, sym_ID }, 13 }, { { 34, sym_CONST }, 3 },
   { { 1, sym_NNF }, 11 }, { { 57, sym_EQUIV }, 34 }, { { 12, sym_AND }, 33 }, { { 29, sym_NOT }, 4 }, { { 4, sym_NOT }, 4 },
   { { 59, sym_IMP }, 32 }, { { 1, sym_Var }, 6 }, { { 33, sym_DIA }, 17 }, { { 5, sym_Index }, 23 }, { { 44, sym_CONST }, 3 },
   { { 5, sym_ID }, 21 }, { { 7, sym_Index }, 24 }, { { 12, sym_OR }, 31 }, { { 4, sym_DIASTART }, 7 }, { { 17, sym_CONST }, 3 },
   { { 8, sym_NNF }, 11 }, { { 5, sym_NUMBER }, 22 }, { { 42, sym_DIASTART }, 7 }, { { 8, sym_ID }, 13 }, { { 47, sym_AND }, 33 },
   { { 12, sym_SEMICOLON }, 30 }, { { 8, sym_NOT }, 4 }, { { 42, sym_Var }, 6 }, { { 26, sym_RIGHTPAR }, 46 }, { { 8, sym_CONST }, 3 },
   { { 40, sym_BOXSTART }, 5 }, { { 8, sym_BOX }, 18 }, { { 12, sym_EQUIV }, 34 }, { { 43, sym_METAVAR }, 19 }, { { 4, sym_BOX }, 18 },
   { { 1, sym_DIA }, 17 }, { { 41, sym_AND }, 33 }, { { 10, sym_BECOMES }, 28 }, { { 17, sym_METAVAR }, 19 }, { { 44, sym_BOXSTART }, 5 },
   { { 15, sym__recover_ }, 36 }, { { 14, sym_NNF }, 11 }, { { 33, sym_CONST }, 3 }, { { 8, sym_LEFTPAR }, 8 }, { { 17, sym_NNF }, 11 },
   { { 14, sym_Formula }, 35 }, { { 4, sym_METAVAR }, 19 }, { { 31, sym_BOXSTART }, 5 }, { { 36, sym_SEMICOLON }, 55 }, { { 28, sym_NNF }, 11 },
   { { 29, sym__recover_ }, 48 }, { { 29, sym_NNF }, 11 }, { { 29, sym_METAVAR }, 19 }, { { 29, sym_DIA }, 17 }, { { 29, sym_BOX }, 18 },
   { { 29, sym_BOXSTART }, 5 }, { { 53, sym_IMP }, 32 }, { { 31, sym_Formula }, 50 }, { { 43, sym_CONST }, 3 }, { { 34, sym_NNF }, 11 },
   { { 29, sym_LEFTPAR }, 8 }, { { 31, sym_ID }, 13 }, { { 42, sym_Formula }, 58 }, { { 47, sym_IMP }, 32 }, { { 31, sym_Var }, 6 },
   { { 58, sym_EQUIV }, 34 }, { { 31, sym_DIASTART }, 7 }, { { 31, sym_NOT }, 4 }, { { 31, sym_DIA }, 17 }, { { 32, sym_ID }, 13 },
   { { 43, sym_Formula }, 59 }, { { 32, sym_Var }, 6 }, { { 32, sym_NOT }, 4 }, { { 32, sym_METAVAR }, 19 }, { { 32, sym_DIA }, 17 },
   { { 49, sym_EQUIV }, 34 }, { { 14, sym_Var }, 6 }, { { 32, sym_BOX }, 18 }, { { 14, sym_NOT }, 4 }, { { 32, sym_BOXSTART }, 5 },
   { { 33, sym_Formula }, 52 }, { { 38, sym_IMP }, 32 }, { { 24, sym_DIAEND }, 44 }, { { 33, sym_Var }, 6 }, { { 48, sym_RIGHTPAR }, 62 },
   { { 33, sym_LEFTPAR }, 8 }, { { 42, sym_CONST }, 3 }, { { 33, sym_NNF }, 11 }, { { 35, sym_IMP }, 32 }, { { 33, sym_BOX }, 18 },
   { { 35, sym_AND }, 33 }, { { 32, sym_LEFTPAR }, 8 }, { { 34, sym_ID }, 13 }, { { 34, sym_Var }, 6 }, { { 31, sym_CONST }, 3 },
   { { 49, sym_RIGHTPAR }, 63 }, { { 34, sym_DIASTART }, 7 }, { { 34, sym_NOT }, 4 }, { { 43, sym_NOT }, 4 }, { { 34, sym_METAVAR }, 19 },
   { { 34, sym_DIA }, 17 }, { { 35, sym_OR }, 31 }, { { 37, sym_SEMICOLON }, 56 }, { { 38, sym_EQUIV }, 34 }, { { 40, sym_ID }, 13 },
   { { 40, sym_Var }, 6 }, { { 40, sym_DIASTART }, 7 }, { { 42, sym_ID }, 13 }, { { 40, sym_LEFTPAR }, 8 }, { { 47, sym_SEMICOLON }, 61 },
   { { 40, sym_BOX }, 18 }, { { 40, sym_NNF }, 11 }, { { 31, sym_METAVAR }, 19 }, { { 40, sym_NOT }, 4 }, { { 40, sym_METAVAR }, 19 },
   { { 14, sym_DIASTART }, 7 }, { { 41, sym_EQUIV }, 34 }, { { 1, sym_BOX }, 18 }, { { 41, sym_IMP }, 32 }, { { 33, sym_METAVAR }, 19 },
   { { 42, sym_NOT }, 4 }, { { 42, sym_BOXSTART }, 5 }, { { 42, sym_METAVAR }, 19 }, { { 43, sym_ID }, 13 }, { { 43, sym_LEFTPAR }, 8 },
   { { 43, sym_BOX }, 18 }, { { 43, sym_BOXSTART }, 5 }, { { 42, sym_LEFTPAR }, 8 }, { { 44, sym_ID }, 13 }, { { 44, sym_Var }, 6 },
   { { 44, sym_LEFTPAR }, 8 }, { { 44, sym_NOT }, 4 }, { { 44, sym_NNF }, 11 }, { { 44, sym_DIA }, 17 }, { { 44, sym_BOX }, 18 },
   { { 44, sym_METAVAR }, 19 }, { { 47, sym_OR }, 31 }, { { 47, sym_EQUIV }, 34 }, { { 49, sym_AND }, 33 }, { { 49, sym_OR }, 31 }
};

parser::statesymbol::map< std::vector< size_t >> parser::reductions =
{
   { { 60, sym_OR }, { 18 } }, { { 60, sym_IMP }, { 18 } }, { { 60, sym_EQUIV }, { 18 } }, { { 60, sym_SEMICOLON }, { 18 } },
   { { 59, sym_RIGHTPAR }, { 16 } }, { { 59, sym_OR }, { 16 } }, { { 59, sym_EQUIV }, { 16 } }, { { 59, sym_SEMICOLON }, { 16 } },
   { { 58, sym_RIGHTPAR }, { 15 } }, { { 58, sym_OR }, { 15 } }, { { 58, sym_IMP }, { 15 } }, { { 58, sym_EQUIV }, { 15 } },
   { { 58, sym_SEMICOLON }, { 15 } }, { { 57, sym_RIGHTPAR }, { 17 } }, { { 57, sym_OR }, { 17 } }, { { 57, sym_IMP }, { 17 } },
   { { 60, sym_RIGHTPAR }, { 18 } }, { { 57, sym_EQUIV }, { 17 } }, { { 57, sym_SEMICOLON }, { 17 } }, { { 39, sym_Var }, { 27 } },
   { { 39, sym_SEMICOLON }, { 26 } }, { { 39, sym_EQUIV }, { 26 } }, { { 39, sym_OR }, { 26 } }, { { 39, sym_BOXSTART }, { 27 } },
   { { 39, sym_IMP }, { 26 } }, { { 50, sym_AND }, { 12 } }, { { 39, sym_AND }, { 26 } }, { { 39, sym_DIA }, { 27 } },
   { { 39, sym_RIGHTPAR }, { 26 } }, { { 39, sym_NOT }, { 27 } }, { { 50, sym_IMP }, { 12 } }, { { 50, sym_OR }, { 12 } },
   { { 20, sym_SEMICOLON }, { 10 } }, { { 59, sym_IMP }, { 16 } }, { { 20, sym_EQUIV }, { 10 } }, { { 38, sym_OR }, { 20 } },
   { { 38, sym_SEMICOLON }, { 20 } }, { { 39, sym_BOX }, { 27 } }, { { 20, sym_IMP }, { 10 } }, { { 38, sym_RIGHTPAR }, { 20 } },
   { { 53, sym_SEMICOLON }, { 14 } }, { { 53, sym_EQUIV }, { 14 } }, { { 39, sym_METAVAR }, { 27 } }, { { 38, sym_AND }, { 20 } },
   { { 20, sym_RIGHTPAR }, { 10 } }, { { 53, sym_OR }, { 14 } }, { { 39, sym_ID }, { 27 } }, { { 39, sym_NNF }, { 27 } },
   { { 38, sym_IMP }, { 20 } }, { { 39, sym_CONST }, { 27 } }, { { 39, sym_LEFTPAR }, { 27 } }, { { 50, sym_RIGHTPAR }, { 12 } },
   { { 41, sym_SEMICOLON }, { 19 } }, { { 39, sym_Formula }, { 27 } }, { { 41, sym_EQUIV }, { 19 } }, { { 41, sym_AND }, { 19 } },
   { { 52, sym_OR }, { 11 } }, { { 39, sym_DIASTART }, { 27 } }, { { 41, sym_IMP }, { 19 } }, { { 52, sym_AND }, { 11 } },
   { { 41, sym_OR }, { 19 } }, { { 38, sym_EQUIV }, { 20 } }, { { 41, sym_RIGHTPAR }, { 19 } }, { { 52, sym_IMP }, { 11 } },
   { { 50, sym_SEMICOLON }, { 12 } }, { { 58, sym_AND }, { 15 } }, { { 53, sym_RIGHTPAR }, { 14 } }, { { 50, sym_EQUIV }, { 12 } },
   { { 51, sym_SEMICOLON }, { 13 } }, { { 59, sym_AND }, { 16 } }, { { 51, sym_EQUIV }, { 13 } }, { { 20, sym_OR }, { 10 } },
   { { 51, sym_AND }, { 13 } }, { { 20, sym_AND }, { 10 } }, { { 51, sym_IMP }, { 13 } }, { { 51, sym_OR }, { 13 } },
   { { 51, sym_RIGHTPAR }, { 13 } }, { { 52, sym_SEMICOLON }, { 11 } }, { { 60, sym_AND }, { 18 } }, { { 52, sym_EQUIV }, { 11 } },
   { { 57, sym_AND }, { 17 } }, { { 52, sym_RIGHTPAR }, { 11 } }, { { 53, sym_AND }, { 14 } }, { { 53, sym_IMP }, { 14 } }
};



