
//  Copyright <2021> <Hans de Nivelle>
//
//  This software is released with the 3-clause BSD license, which 
//  is given below: 
// 
//  Redistribution and use in source and binary forms, with or without 
//  modification, are permitted provided that the following conditions are met:

//  Redistributions of source code must retain the above copyright notice, 
//  this list of conditions and the following disclaimer:

//  Redistributions in binary form must reproduce the above copyright notice, 
//  this list of conditions and the following disclaimer in the documentation 
//  and/or other materials provided with the distribution.
//  Neither the name of the copyright holder nor the names of its contributors 
//  may be used to endorse or promote products derived from this software 
//  without specific prior written permission.

//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
//  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
//  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
//  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
//  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
//  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED 
//  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
//  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
//  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



// Parser generated by Maphoon 2021.
// Written by Hans de Nivelle, March 2021.
// See the licence that was included with the code. 

#ifndef PARSER 
#define PARSER   1

#include <vector>
#include <iostream>
#include <unordered_set>
#include <unordered_map>

#include "symbol.h"

#line 37 "grammar.m"
 #include "tokenizer.h" 
 #include "varstore.h" 
#line 18 "idee.x"
 

  
struct parser
{

   struct statesymbol
   {
      size_t state;
      symboltype type;

      statesymbol( size_t state, symboltype type )
         : state( state ), type( type )
      { }

      struct hash
      {
         size_t operator( ) ( const statesymbol& ) const;
      };

      struct equal_to
      {
         bool operator( ) ( const statesymbol &, const statesymbol& ) const;
      };

      template< typename D > using map =
      std::unordered_map< statesymbol, D, hash, equal_to > ;
   };


   static std::unordered_map< symboltype,
      std::pair< size_t, std::unordered_set< symboltype >>> 
   startsymbols;
      // Maps possible start symbols to pairs of
      // initial state, and terminator sets.

   static 
   std::vector< std::pair< char, size_t >> reductioninfo; 
      // Indexed by the states.
      // char = 'T' : the state consists of a single reduction (trivial).
      // char = 'D' : the state has a default reduction, which will be
      //              carried out when lookahead has no shift.
      // char = 'N' : the state has no reductions.
      // char = 'H' : none of the above. The state is hard.

   static statesymbol::map< size_t > shifts; 
   static statesymbol::map< std::vector< size_t >> reductions;

   std::vector< size_t > statestack;
   std::vector< symbol > symbolstack;
   std::optional< symbol > lookahead;

   unsigned int lasterror = 999999;
      // Symbols that were processed since the last error. 

   bool timetosaygoodbye = false; 
      // If you assign true, the parser will assume that 
      // it is really time to say goodbye. No more symbols will 
      // be read. 

   short int debug = 0;  
      // 0 : no output
      // 1 : only the parse stack
      // 2 : chosen shifts and reductions
      // 3 : attempted reductions. 

   // Parameters, defined by %parameters:

   tokenizer & tok;
   varstore<form> & vs;


   parser( tokenizer & tok,
           varstore<form> & vs )
      : tok( tok ),
        vs( vs )
   { }


   // i-th symbol on the symbolstack, looking backwards:
   // This means that 0 is undefined, 1 is .back( ), etc. 

   symbol& topsymbol( size_t i )
      { return *( symbolstack. end( ) - i ); }

   const symbol& topsymbol( size_t i ) const
      { return *( symbolstack. cend( ) - i ); }

#if false
   static void merge_infos( symbol::infotype& ,
                            symbol::infotype&& ); 
#endif

   void reduce( symboltype lefttype, 
                symbol::attrtype&& attr, size_t rightsize );

   symbol parse( symboltype start );

   void print( std::ostream& out ) const;
      // Prints the state of the parser.

   unsigned int syntaxerror( );
      // When we encounter an error, the parser calls this function.
      // The number returned is our patience when trying to recover.
      // 0 means that we do not try to recover at all. 10 means that 
      // we try to recover for 10 symbols, etc. I remember from Yacc
      // that 3 is a good value. 
      // 
      // First thing that the function should do is look at lasterror,
      // and decide if this is a new error, or a failure to recover from   
      // the previous error. 

   // Declarations of reduction functions and their conditions:
   // They have no arguments because they use the stack.

   form body2( );
   form body3( );
   form body4( );
   form body5( );
   form body6( );
   form body7( );
   form body8( );
   form body9( );
   short cond10( ) const;
   form body10( );
   short cond11( ) const;
   form body11( );
   short cond12( ) const;
   form body12( );
   short cond13( ) const;
   form body13( );
   short cond14( ) const;
   form body14( );
   short cond15( ) const;
   form body15( );
   short cond16( ) const;
   form body16( );
   short cond17( ) const;
   form body17( );
   short cond18( ) const;
   form body18( );
   short cond19( ) const;
   form body19( );
   short cond20( ) const;
   form body20( );
   form body21( );
   form body22( );
   form body23( );
   form body24( );
   form body25( );
   std::string body26( );
   agent body27( );
   agent body28( );


};



#endif

