
//  Copyright <2021> <Hans de Nivelle>
//
//  This software is released with the 3-clause BSD license, which 
//  is given below: 
// 
//  Redistribution and use in source and binary forms, with or without 
//  modification, are permitted provided that the following conditions are met:

//  Redistributions of source code must retain the above copyright notice, 
//  this list of conditions and the following disclaimer:

//  Redistributions in binary form must reproduce the above copyright notice, 
//  this list of conditions and the following disclaimer in the documentation 
//  and/or other materials provided with the distribution.
//  Neither the name of the copyright holder nor the names of its contributors 
//  may be used to endorse or promote products derived from this software 
//  without specific prior written permission.

//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
//  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
//  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
//  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
//  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
//  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED 
//  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
//  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
//  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



// Code written by Hans de Nivelle, November 2006.
// Rewritten June 2008.
// See the licence that was included with this code.

#include "symbolcodebuilder.h"
#include "cpp.h"
#include "indentation.h"

bool symbolcodebuilder::addsymbol( symbol sym, const cpp::type& tp )  
{
   auto p = attributes. insert( std::pair( sym, tp ));
   return p. second; 
}

cpp::type::set 
symbolcodebuilder::getallpossibletypes( ) const
{
   cpp::type::set all;

   for( const auto& attr : attributes )
   {
      if( !attr.second.isvoid( ))
      {
         all. insert( attr. second );
            // nur der Void darf nicht mit Heut. 
      }
   }

   return all; 
}

void symbolcodebuilder::printconstructor( 
   indentation ind, std::ostream& out,
   const cpp::type & attrtype, cpp::type::cv_ref r ) const
{
   out << ind << "symbol( symboltype type"; 
   ind += 8; 

   if( !infotype. isvoid( )) 
   { 
      out << ",\n" << ind; 
 
      // Light types result in a value parameter, heavy types
      // in a const& parameter:
 
      if( infotype. islight( )) 
         out << "std::optional<infotype> info";  
      else
         out << "const std::optional<infotype> & info";  
   }

   if( !attrtype. isvoid( ))
   {
      out << ",\n" << ind;
      attrtype. printascode( out, r ); 
      out << " attr )\n";
   }
   else
      out << " )\n";
 
   ind -= 8;

   out << ind << " : type( type )"; 
   ind += 3;

   if( !infotype. isvoid( )) 
   {
      out << ",\n" << ind; 
      out << "info( info )"; 
   }

   if( !attrtype. isvoid( ))
   {
      out << ",\n" << ind;
      if( r == cpp::type::mref ) 
         out << "attr( std::move( attr ))";
      else
         out << "attr( attr )";
   }

   ind -= 3; 
   out << "\n"; out << ind << "{ }\n\n";
}


void symbolcodebuilder::print_h_file( std::ostream& out ) const 
{
   out << "\n"; 
   out << "// The code below was generated by Maphoon 2021.\n\n";
   out << "// Definition of struct symbol:\n\n"; 
   std::string guard = space. includeguard( "symbol" ); 
   out << "#ifndef " << guard << "\n";
   out << "#define " << guard << "    1\n";
   out << "\n";

   out << "#include <iostream>\n"; 
   out << "#include <variant>\n"; 
   out << "#include <optional>\n";
   out << "#include <stdexcept>\n";

   out << "\n"; 


   code_h. printascode( out );
   if( code_h. size( ))
      out << "\n"; 

   space. open( out ); 

   indentation ind; 
   if( space. size( ))
      ind += 3;

   out << ind << "enum symboltype\n";
   out << ind << "{\n";

   {
      ind += 3;
      out << ind; 
      size_t column = 0; 
      for( auto p = attributes. begin( ); p != attributes. end( ); ++ p )
      {
         if( p != attributes. begin( ))
            out << ", ";
         if( column == 4 ) 
         {
            out << "\n" << ind; 
            column = 0;
         }
         ++ column;
         out << "sym_" << p -> first;
      }
      ind -= 3;
      out << "\n";
      out << ind << "};\n"; 
   }

   out << "\n"; 
   out << ind << "const char* getcstring( symboltype );\n\n";
   out << ind << "inline std::ostream& operator << ";
   out << "( std::ostream& out, symboltype tp )\n";
   out << (ind+3) << "{ out << getcstring( tp );  return out; }\n"; 

   out << "\n";
   out << ind << "struct symbol\n";
   out << ind << "{\n";
   
   ind += 3;

   cpp::type::set alltypes = getallpossibletypes( );

   out << ind << "using attrtype = std::variant < std::monostate";
   size_t i = 0;

   for( const auto& opt : alltypes )
   {
      out << ", ";

      if( i % 4 == 2 )
         out << "\n" << ind << "      ";

      opt. printascode( out, cpp::type::value ); 

      ++ i;
   }
   out << " > ;\n\n";

   if( !infotype. isvoid( ))
   {
      out << ind << "using infotype = ";
      infotype. printascode( out, cpp::type::value );
      out << ";\n\n"; 
   }
 
   out << ind << "symboltype type;\n";
   if( !infotype. isvoid( )) out << ind << "std::optional<infotype> info;\n"; 
   out << ind << "attrtype attr;\n";
   out << "\n";

   // We define the copy constructors, assignment and the destructor:

   out << ind << "symbol( ) = delete;\n";
   out << ind << "symbol( const symbol& ) = default;\n";
   out << ind << "symbol( symbol&& ) noexcept = default;\n";
   out << ind << "symbol& operator = ( const symbol& ) = default;\n";
   out << ind << "symbol& operator = ( symbol&& ) noexcept = default;\n";
   out << ind << "~symbol( ) = default;\n";
   out << "\n";

   printconstructor( ind, out, cpp::type( "void" ), cpp::type::value );
   printconstructor( ind, out, cpp::type( "attrtype" ), cpp::type::mref );

   for( const auto& tp : alltypes ) 
   {
      if( tp. islight( ))
         printconstructor( ind, out, tp, cpp::type::value );
      else
      { 
         printconstructor( ind, out, tp, cpp::type::cref ); 
         printconstructor( ind, out, tp, cpp::type::mref ); 
      }
   }
   out << "\n";

   out << ind << "void print( std::ostream& out ) const;\n\n";
   out << ind << "template< typename T > const T& get( ) const\n"; 
   out << ind << "   { return std::get<T> ( attr ); }\n"; 
   out << ind << "\n";

   out << ind << "template< typename T > T& get( )\n";
   out << ind << "   { return std::get<T> ( attr ); }\n"; 
   out << ind << "\n";

 
   ind -= 3;
 
   out << ind << "};\n";
   out << "\n";
   out << ind << "inline\n";
   out << ind << "std::ostream& operator << ( ";
   out << "std::ostream& out, const symbol& sym )\n";
   out << ind << "   { sym. print( out ); return out; }\n";

   out << "\n\n";

   space. close( out ); 

   if( space. size( )) 
      out << "\n";

   out << "#endif\n";
   out << "\n\n";
}

void symbolcodebuilder::print_cpp_file( std::ostream& out ) const 
{
   out << "\n"; 
   out << "// This code was produced by Maphoon 2021.\n";
   out << "// Code for struct symbol:\n";
 
   out << "\n";
   out << "#include \"symbol.h\"\n\n\n";

   indentation ind;
   if( !code_cpp.empty ( ))
   {
      space. open( out );
      ind += 3;

      code_cpp. printascode( out );
      ind -= 3;
      space. close( out );
      out << "\n";
   }

   out << "const char* "; space. printasprefix( out ); 
   out << "getcstring( symboltype tp )\n";
   out << "{\n";

   ind += 3;
   out << ind << "switch( tp )\n";
   out << ind << "{\n";

   for( const auto& a : attributes )
   {
      out << ind << "case " << "sym_" << a.first << ":\n";
      out << (ind+3) << "return \"" << a.first << "\";\n";
   }
   out << ind << "}\n";
   out << ind << "return \"(unknown symbol type)\";\n";
   out << "      // unreachable, but makes the compiler shut up\n";
   ind -= 3;
   out << ind << "}\n";
   out << "\n";


   out << "// If you see a big error message originating from\n";
   out << "// symbol::print( ), then the most likely reason is that\n";
   out << "// one of the possible attribute types or the info type has \n"; 
   out << "// no definition for operator << .\n";
   out << "// You can either remove it from print( ), or \n";
   out << "// define operator << (if necessary as dummy). \n"; 
   out << "\n";

   ind. clear( );

   out << "void "; space.printasprefix( out ); out << "symbol::print( ";
   out << "std::ostream& out ) const\n";
   out << "{\n";

   ind += 3; 
   out << ind << "out << \"sym_\" << type << \"(\";\n\n";
  
   auto alltypes = getallpossibletypes( ); 

   if( !infotype. isvoid( )) 
   {
      out << ind << "if( info. has_value( ))\n"; 
      out << (ind+3) << "out << info. value( );\n\n";
   }

   out << ind << "if( std::holds_alternative< std::monostate > ( attr ))\n";
   out << (ind+3) << "{ out << \")\"; return; }\n\n";

   if( !infotype. isvoid( ) && alltypes. size( )) 
   {
      out << ind << "if( info. has_value( ))\n";
      out << (ind+3) << "out << \",\";\n\n";
   }

   for( const auto& opt : alltypes ) 
   {
      out << ind << "if( std::holds_alternative< ";
      opt. printascode( out, cpp::type::value );
      out << " > ( attr ))\n";
    
      out << (ind+3) << "{ out << std::get<";
      opt. printascode( out, cpp::type::value );
      out << "> ( attr ) << \")\"; return; }\n"; 
   }

   if( alltypes. size( ))
      out << "\n";

   out << ind << "throw std::runtime_error( \"should be unreachable\" );\n"; 
   out << "}\n\n";
}


std::ostream& 
operator << ( std::ostream& out, const symbolcodebuilder& bld )
{
   out << "symbolcodebuilder:\n\n";
   if( !bld. code_h. empty( )) 
      out << "code for .h:\n" << bld. code_h << "\n";

   out << "namespace:\n   " << bld. space << "\n\n";

   out << "infotype: " << bld. infotype << "\n\n";

   if( !bld. code_cpp. empty( )) 
      out << "code for .cpp:\n"; out << bld. code_cpp << "\n";

   out << "declared attributes:\n"; 

   for( const auto& a : bld. attributes ) 
      out << "   " << a. first << " : " << a. second << "\n";
   out << "\n";

   return out;
}


